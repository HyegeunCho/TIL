# 개요

자바스크립트는 클래스가 없으며, 함수는 일급 객체로 다양한 작업에 사용된다.
일급 객체는 다음과 같은 특성이 있다.

- 변수나 데이터 구조 안에 담을 수 있다.
- 인자로 전달할 수 있다.
- 반환값으로 사용할 수 있다.
- 런타임에 생성할 수 있다.
- 할당에 사용된 이름과 관계없이 고유하게 식별할 수 있다.

## 자바스크립트의 개념

### 객체지향

자바스크립트에서 변수를 선언했다면 이미 객체를 다루고 있는 것.

1. 변수는 자동으로 활성화 객체(Activation Object)라 불리는 내부적인 객체의 프로퍼티가 된다. (전역 변수인 경우 전역 객체의 프로퍼티가 된다.)
2. 변수는 자신만의 프로퍼티를 가지므로 실제 객체와 비슷한다.

객체는 단지 이름이 지정된 프로퍼티의 모음이며, 키 - 값 쌍으로 이뤄진 목록이다.

자바스크립트에는 두 가지 주요 객체 타입이 있다.

1. 네이티브 객체 : ECMAScript 표준에 정의된 객체
    - 내장 객체 (Array나 Date) 또는 사용자 정의 객체
2. 호스트 객체 : 호스트 환경에서 정의된 객체
    - window 객체나 모든 DOM 객체

### 클래스가 없다

자바스크립트에서는 빈(blank) 객체를 필요한 시점에 생성하고 그 이후에 필요한 멤버를 추가할 수 있다.

빈 객체는 몇몇 내장 프로퍼티를 이미 가지고 있지만 자신이 직접 소유(own)한 프로퍼티가 없을 뿐이다.

### 프로토타입

자바스크립트에서 상속은 프로토타입으로 구현한다.

프로토타입은 클래스나 어떤 특별한 것이 아니고 객체라는 사실과 모든 함수가 prototype 프로퍼티를 가진다는 것을 기억하자.

# 기초

## 유지보수 가능한 코드 작성

- 읽기 쉬워야 한다.
- 일관적이어야 한다.
- 예측 가능해야 한다.
- 한 사람이 작성한 것처럼 동일한 코딩 규칙을 사용해야 한다.
- 문서화 되어야 한다.

## 전역 변수 최소화

자바스크립트는 함수를 사용하여 변수의 유효범위를 관리한다.

모든 자바스크립트 실행 환겨에는 전역 객체(global object)가 존재한다.
어떤 함수에도 속하지 않은 상태에서 this를 사용하면 전역 객체에 접근하게 된다.
전역 변수를 생성하는 것은, 이 전역 객체의 프로퍼티를 만드는 것과 같다.

```javascript
myglobal = "hello";                // 안티 패턴
console.log(myglobal);             // hello
console.log(window.myglobal);      // hello
console.log(window["myglobal"]);   // hello 
console.log(this.myglobal);        // hello
```

### 전역 변수의 문제점

전역 변수의 문제점은 애플리케이션이나 웹페이지 내 모든 코드 사이에서 공유된다는 점.
즉, 모든 전역 변수는 동일한 전역 네임스페이스 안에 존재하기 때문에, 애플리케이션 내의 다른 영역에서 목적이 다른 전역 변수를 동일한 이름으로 정의할 경우 서로 덮어쓰게 된다.

다른 스크립트들과 공존하려면 전역 변수를 최소한으로 사용해야 한다.

**변수를 선언할 때 항상 var를 사용하자.**

자바스크립트에는 **암묵적 전역(implied galobals)**이라는 개념이 있어서, 선언하지 않고 사용한 변수는 자동으로 전역 객체의 프로퍼티가 되어 명시적으로 선언된 전역 변수와 별 차이 없이 사용할 수 있다.

```javascript
function sum(x, y) {
    // 안티패턴 : 암묵적 전역
    result = x + y;
    return result;
}
```

위 코드에서 result는 선언되지 않은 상태로 사용되어 전역 객체의 멤버가 되었다.
함수사용 완료 후에도 여전히 전역 스코프에 result가 남아서 오동작을 일으킬 수 있다.

위 코드를 개선하면 다음과 같다.

```javascript
function sum(x, y) {
    var result = x + y;
    return result;
}
```

암묵적 전역을 생성하는 또 다른 안티패턴은 하나의 var 선언에서 연쇄적으로 할당을 사용하는 것.

```javascript
function foo() {
    // 안티패턴
    var a = b = 0;
}
```

위에서 변수 a는 var의 영향을 받아 지역변수가 된다.
변수 b는 전역변수가 된다.
그 이유는 평가가 오른쪽에서 왼쪽으로 진행되기 때문.

변수를 미리 선언해두면 의도치 않은 전역 변수가 생성되는 일이 없기 때문에, 연쇄할당문을 사용해도 문제가 없다.

```javascript
function foo() {
    var a, b;
    a = b = 0; // 모두 지역변수
}
```

> 암묵적 전역 변수를 피해야 하는 또 다른 이유는 이식성 때문. 암묵적 전역 변수가 새로운 실행환경의 호스트 객체를 의도치 않게 덮어써버릴 수 있다.

### var 선언을 빼먹었을 떄의 부작용

var를 사용하지 않고 생성한 암묵적 전역 변수는 delete 명령을 사용해 삭제할 수 있다.

delete는 프로퍼티는 삭제할 수 있으나, 변수는 삭제할 수 없다.

암묵적 전역 변수는 전역 객체의 프로퍼티이므로 delete로 삭제할 수 있다.

### 전역 객체에 대한 접근

전역 객체에 접근하고 싶다면, 함수 유효범위 안에서 다음과 같이 정의하면 된다.

```javascript
var global = (function() {
    return this;
}());
```

1. 함수를 new와 생성자를 사용해 호출하지 않고 그냥 함수로 호출한 경우, 함수 안에서 this는 항상 전역 객체를 가리킨다.
2. 라이브러리 코드를 즉시 실행 함수로 감싼 후, 즉시 실행 함수의 인자로 전역 유효범위를 가리키는 this를 전달하는 방법이 있다.

### 단일 var 패턴

함수 상단에서 var 선언을 한 번만 쓴느 패턴은 유용한다.

- 모든 지역 변수를 한군데서 찾을 수 있다.
- 변수를 선언하기 전에 사용할 때 발생하는 로직상의 오류를 막을 수 있다. (hoisting 이슈)
- 전역 변수를 최소화하는데 도움이 된다.
- 코드량이 줄어든다.

```javascript
function func() {
    var a = 1, 
        b = 2, 
        sum = a + b, 
        myobject = {},
        i, 
        j;
}
```

var 선언을 하나만 쓰고 여러 개의 변수를 쉼표로 연결하여 선언.

변수를 선언할 때 초기값을 주어 초기화하는 것 역시 좋은 습관

### 호이스팅 : 분산된  var 선언의 문제점

자바스크립틔에서는 함수 내 여기저기에서 var 선언을 할 수 있으나, 실제로는 모두 함수 상단에서 변수가 선언된 것과 동일하게 동작한다. 이것을 호이스팅이라고 한다.
때문에 함수 안에서 변수를 사용한 다음에 선언하면 로직상의 오류를 일으킬 수 있다.

```javascript
// 안티패턴
myname = "global";  // 전역 변수
function func() {
    alert(myname);  // "undefined"
    var myname = "local";
    alert(myname);  // "local"
}
```

첫번째 alert은 undefined를 출력한다. myname이 이 함수의 지역변수로 선언되었다고 간주하기 때문.
모든 변수 선언문은 함수 상단으로 끌어올려진다.

호이스팅이 적용된 이후의 동작을 코드로 나타내면 아래와 같다.

```javascript
myname = "global";  // 전역 변수
function func() {
    var myname;  // 이렇게 쓴 것과 동일 -> var myname = undefined;
    alert(myname);  // "undefined"
    myname = "local";
    alert(myname);  // "local"
}
```

## for 루프

일반적인 for 루프는 다음과 같다.

```javascript
// 최적화되지 않은 루프
for (var i = 0; i < myarray.length; i++) {
    // myarray[i]를 다루는 코드
}
```

위 코드의 문제점은 루프 순회시마다 배열의 length에 접근한다는 것.

실행환경에 따라 객체의 length에 접근하는 비용이 비싼 경우가 있다.

따라서 아래와 같이 length를 캐싱하여 최적화할 수 있다.

```javascript
for (var i = 0, max = myarray.length; i < max; i--) {
    // myarray[i]를 다루는 코드
}
```

**JSLint**는 -- 가 아니라 i = i - 1, i -= 1 을 사용하는 것을 요구한다.

## for-in 루프

for-in 루프는 객체를 순회할 때만 사용해야 한다.

객체를 순회할 때에는 상속되는 프로퍼티들을 걸러내기 위해 자신이 직접 소유한 멤버, 메서드를 확인하는 **hasOwnProperty()**메서드를 사용해야 한다.

## 암묵적 타입캐스팅 피하기

암묵적 타입캐스팅으로 인한 혼동을 막기 위해서, 항상 표현식의 값과 타입을 모두 확인하는 **===**, **!==** 연산자를 사용한다.

## eval() 피하기

eval() 함수는 문자열 또는 객체로 넘겨진 자바스크립트 명령을 실행하는 함수이다.

보안상의 이유, 전역 변수 오염등의 이유로 eval 사용을 최소화 해야 한다.

## parseInt()를 통한 숫자 변환

parseInt() 함수는 문자열 숫자를 숫자로 변환하는 함수이다. 이 때 두번째 인자 "기수 매개변수"를 항상 설정해 줘야 한다.

## 들여쓰기

들여쓰기를 사용하지 않는 것보다 더 나쁜 것은 일관성 없는 들여쓰기이다.

## 중괄호 

중괄호는 생략할 수 있을 때에도 항상 써야 한다.

for문과 if문에 내용이 한줄만 있는 것과 같이 중괄호를 생략할 수 있는 경우에도 항상 중괄호를 사용하자.

## 여는 중괄호 위치

자바스크립트는 스테이트먼트의 끝에 세미콜론이 없는 경우 자동으로 세미콜론을 붙여 준다.

그런데 이때 여는 중괄호 위치에 따라 로직의 동작이 달라질 수 있다.

그러므로 자바스크립트에서는 여는 중괄호를 항상 선행하는 명령문과 동일한 행에 두자.

## API 문서 작성

- [JSDoc 툴킷](http://code.google.com/p/jsdoc-toolkit)
- [YUIDoc](http://yuilibrary.com/projects/yuidoc)

## 출시 단계의 압축

- YUI 컴프레서
- 구글의 클로저 컴파일러

## JSLint의 실행

