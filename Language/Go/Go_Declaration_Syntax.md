# C syntax

```c
int x;
int *p;
int a[3];
```

C 언어에서는 일반적으로 변수의 타입을 정의할 때 변수 표현식을 오른쪽에 타입을 왼쪽에 명시한다.

함수의 경우도 마찬가지로 괄호의 바깥 가장 왼쪽에 변환값의 타입을 명시한다.

현대적인 표기법으로 정리하면 아래와 같다.

```c
int main(int argc, char *argv[]) { /*...*/ }
```

이러한 표기법은 간단한 타입들에 대해선 잘 동작하지만 금새 혼란스러워질 수 있다.

예를 들어 C 언어의 타입 명시 방법으로 함수 포인터를 정의해보자.

```c
int (*fp)(int a, int b);
```

이 정도의 함수 시그니쳐라면 읽기 불편하진 않다.

하지만 첫번째 인수에 다시 함수 포인터가 들어가면 어떨까?

```c
int (*fp)(int (*ff)(int x, int y), int b)
```

물론 함수 시그니쳐에서 인자의 네임을 제거해서 표기를 좀 더 단순화할 수 있다.

```c
int (*fp)(int (*)(int, int), int)
```

좀 더 복잡해지기 시작하면 대체 인수명 표현식을 어디다 넣어서 읽어야 하는지도 헷갈리기 시작한다.

```c
int (*(*fp)(int (*)(int, int), int))(int, int)
```

# Go Syntax

C 계열이 아닌 언어들은 아래와 같이 타입 선언을 표기하곤 한다.

```
x: int
p: pointer to int
a: array[3] of int
```

이런 표현방법은 명확하고 또 길어지더라도 왼쪽에서 오른쪽으로 읽기 간편하다.

Go 언어의 경우 아래와 같이 변수의 타입을 명시한다.

```go
x int
p *int
a [3]int
```

다음은 Go 언어에서 함수 타입을 명시하는 예제이다.

```go
func main(argc int, argv []string) int
```

C언어와 별차이 없어보이긴 하지만 역시나 왼쪽에서 오른쪽으로 읽기에 편하다

함수가 최종적으로 반환하는 타입이 무엇인지 굳이 다시 왼쪽으로 가서 살펴볼 필요가 없다.

left-to-right 방식의 이점은 타입 선언이 복잡해지더라도 여전히 읽기 쉽다는 것이다.

아래는 C의 함수 포인터 활용과 동일한 