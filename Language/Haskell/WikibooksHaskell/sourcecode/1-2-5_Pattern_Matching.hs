-- 1. 초급반
-- 1-2. 하스켈 초급
-- 1-2-5. 패턴 매칭

--------------------------------------------------
-- 패턴 매칭은 값을 패턴에 일치시키고, 필요하다면 성공적인 일치에 변수를 바인딩하려는 시도다.

--------------------------------------------------
-- [패턴 매칭 분석하기]
-- map 함수의 정의를 분석해 보자
exMap _ [] = []
exMap f (x:xs) = f x : map f xs

-- f는 모든 것에 일치하는 패턴으로 변수 f를 일치하는 무엇에든 바인딩한다.
-- (x:xs)는 비어있지 않은 리스트에 일치하는 패턴으로 변수 x에 바인딩되는 무언가와 xs에 바인딩되는 다른 무언가가 (:) 함수에 의해 연결된다.
-- [] 는 빈 리스트에 일치하는 패턴이다. 아무 변수도 바인딩하지 않는다.
-- _ 는 모든 것에 일치하는 패턴이지만 아무 것도 바인딩하지 않는다.

-- 위 분석을 토대로 다음과 같은 방법들을 추정할 수 있다.
-- 1. 값을 인식한다. map이 호출되고 두 번째 인수가 [] 에 일치하면 map의 두 번째 등식이 아니라 첫번째 등식이 사용된다.
-- 2. 인식된 값에 변수를 바인딩한다. 이 경우 변수 f, x, xs에는 map의 인수로서 전달된 값들이 할당되고 (두 번째 등식이 사용될 경우)
-- = 의 우변에서 이 값들을 변수에 사용할 수 있다. 
-- _와 []가 보여주듯이 바인딩은 패턴 매칭의 필수 요소가 아니며 변수 이름을 패턴으로 쓸 때의 부수 효과일 뿐이다.
-- 3. 값을 분해한다. (x:xs) 패턴이 두 변수를 각각, 일치하는 인수 (비어있지 않은 리스트)의 머리와 꼬리에 바인딩하는 것이 그런 예다.

--------------------------------------------------
-- [생성자와의 연계]
-- 모든 함수가 패턴 매칭에 허용되는 것은 아니다.
data Foo = Bar | Baz Int

f :: Foo -> Int
f Bar = 1
-- f (Baz x) x - 1

-- 위에서 Bar와 Baz는 Foo 타입의 생성자
-- 이것들을 통해 Foo 값을 패턴 매칭하고 Baz에 의해 생성된 Foo에 포함된 Int 값에 변수를 바인딩할 수 있다.
-- Baz에 포함된 변수 x에 값을 바인딩할 수 있다.

-- 이전 타입 선언 과목의 showAnniversary, showDate 함수와 유사한 방식이다.
data Date = Date Int Int Int -- year, month, day
showDate :: Date -> String
showDate (Date y m d) = show y ++ "-" ++ show m ++ "-" ++ show d

-- showDate 정의의 좌변인 (Date y m d) 패턴은 Date 생성자로 만들어진 Date 값과 일치하고 변수 y, m, d를 Date 값의 내용에 바인딩한다.


--------------------------------------------------
-- [리스트에 대해 동작하는 이유]
-- 빈 리스트의 경우 []와 (:) 함수는 list 자료형의 생성자이며 따라서 이것들에 패턴을 일치시킬 수 있다.
-- []은 인수를 취하지 않으므로 패턴 매칭에서 []에는 변수가 바인딩될 수 없다.
-- (:)은 리스트의 머리와 꼬리라는 두 인수를 취해, 패턴이 인식될 경우 변수들이 이 둘에 바인딩한다.

-- [] :: [a]
-- (:) :: a -> [a] -> [a]

-- [x, y, z]는 x:y:z:[]의 구문적 편의일 뿐이기에 dropThree 같은 것은 패턴 매칭만으로 가능하다.
exDropThree :: [a] -> [a]
exDropThree (_:_:_:xs) = xs
exDropThree _ = []


--------------------------------------------------
-- [튜플 생성자]

fstPlusSnd :: (Num a) => (a, a) -> a
fstPlusSnd (x, y) = x + y

norm3D :: (Floating a) => (a, a, a) -> a
norm3D (x, y, z) = sqrt (x^2 + y^2 + z^2)

-- 튜플 역시 생성자가 있기에 위와 같이 사용할 수 있다.


--------------------------------------------------
-- [리터럴 값과의 일치]
-- 다음의 간단한 조각 함수 정의 역시 패턴 매칭을 통해
-- f의 인수를 Int 리터럴 0, 1, 2 그리고 _ 와 일치시킨다.
-- 일반적으로 숫자, 문자 리터럴은 그 자체로 패턴 매칭에 쓰일 수 있다.
-- 생성자 패텅과도 함께 쓰일 수 있다.

g :: [Int] -> Bool
g (0:[]) = False
g (0:xs) = True
g _ = False

-- 리스트 [0]에 대해 False
-- 첫번째 원소가 0인 리스트와 꼬리가 빈 리스트가 아닌 리스트에 대해 True로 
-- 다른 모든 경우에 False로 평가

-- 리터럴이 아닌 경우는 패턴매칭이 동작하지 않는다.

k = 1
h :: Int -> Bool
h k = True
h _ = False


--------------------------------------------------
-- [연습문제]
-- 1. 위의 결함 있는 함수 h를 GHCi에서 1인 인수와 1이 아닌 인수로 시험해보라
-- 그리고나서 뭐가 잘못되었는지 설명하라.
-- -> k는 일종의 Integer 타입을 대변하는 모든 것으로 평가된다. 따라서 1이든 1이 아닌 수이든 Integer 형인 경우는 모두 True를 반환할 것이다.
-- -> 그리고 h 에 Integer가 아닌 값을 인수로 전달하면 함수의 타입과 다르므로 오류가 발생한다.

-- 2. 리터럴값과의 패턴 매칭에 대한 이번 절에서 불리언 값 True와 False는 전혀 언급하지 않았는데, 이 둘도 패턴 매칭이 가능하다.
-- 다음 장에서 설명할 것인데, 왜 이둘을 빠뜨렸는지 추측해보자. (힌트 : 불리언 값을 작성하는 별개의 방법이 있는가?)


--------------------------------------------------
-- [구문 트릭 - as 패턴]
-- 패턴과 값을 일치시킬 때, 일치되는 값 전체에 이름을 바인딩하는 게 유용할 수도 있다.
-- 이를 위한 것이 as 패턴이다.
-- var@pattern 꼴이며, pattern에 매칭되는 전체 값에 이름 var를 바인딩한다.

contriveMap :: ([a] -> a -> b) -> [a] -> [b]
contriveMap f [] = []
contriveMap f list@(x:xs) = f list x : contriveMap f xs

-- contriveMap은 매개 함수 f에 x 뿐 아니라 분리되지 않은 리스트도 재귀호출의 인수로 전달
-- as 패턴 없이는 head를 쓰거나 원래의 list를 불필요하게 재구축, 즉 우변에서 x:xs를 평가해야 했을 것이다.

iContriveMap :: ([a] -> a -> b) -> [a] -> [b]
iContriveMap f [] = []
iContriveMap f (x:xs) = f (x:xs) x : contriveMap f xs


--------------------------------------------------
-- [연습문제]
-- 1. List Processing의 연습문제 scanr을 이번에는 as 패턴을 써서 구현하라.


--------------------------------------------------
-- [구문 트릭 - 레코드의 도입]
-- 원소가 많은 생서자를 위해 레코드는 다음과 같은 구문으로 자료형의 값들에 이름 짓는 방법을 제공
data Foo2 = Bar2 | Baz2 {bazNumber::Int, bazName::String}

-- 레코드를 사용하면 관심있는 변수만 매칭, 바인딩할 수 있어서 코드가 깔끔해진다.
h2 :: Foo2 -> Int
h2 Baz2 {bazName=name} = length name
h2 Bar2 {} = 0

-- data 선언에서 레코드를 쓰지 않더라도 {} 패턴으로 원소들의 데이터타입에 상관없이 생성자를 매칭할 수 있다.

data Foo3 = Bar3 | Baz3 Int
g3 :: Foo3 -> Bool
g3 Bar3 {} = True
g3 Baz3 {} = False

-- 위와 같이 {} 를 사용하여 매개변수를 매칭해놓으면 나중에 생성자 Bar3과 Baz3의 원소들의 개수나 타입을 바꾸더라도 g3을 수정할 필요가 없다.


--------------------------------------------------
-- [패턴 매칭을 쓸 수 있는 곳]
-- 변수를 바인딩하는 모든 곳에서 패턴 매치을 사용할 수 있다.

-- {등식}
-- 가장 명확한 용례는 함수 정의식의 좌변
map _ [] = []
map f (x:xs) = f x : map f xs
-- map 정의에서 두 식의 좌변에서 패턴 매칭을 하며 두 번째 식에서는 변수 바인딩도 한다.

-- {let 표현식과 where 절}
-- let과 where는 로컬 변수 바인딩 수단이다.
y = 
    let
        (x:_) = map (*2) [1,2,3]
    in x + 5

equalY = x + 5
    where
    (x:_) = map (*2) [1,2,3]

-- x는 map ((*) 2) [1,2,3] 의 첫번째 원소에 바인딩된다. 
-- y는 따라서 2 + 5 = 7 로 변환된다.

-- {리스트 조건제시식 (list comprehension)}
-- 리스트 조건제시식에서 | 뒤에 패턴 매칭을 쓸 수 있다.
-- Prelude는 생성자가 다음과 같은 Maybe 타입을 제공한다.
-- Data.Maybe 모듈에서 제공
data MyMaybe a = Nothing | Just a

-- 통상 성공 여부를 모르는 작업의 결과값을 저장하는데 쓰인다.
-- 작업이 성공하면 Just 생서자가 사용되어 결과값이 전달된다.
-- 그렇지 않으면 Nothing이 사용된다.

-- 아래 catMaybes는 Maybe의 목록을 취해 Nothing은 걸러내고 Just x에서 Just 래퍼를 걷어내 
-- 그 안의 값을 얻는다.

catMyMaybes :: [Maybe a] -> [a]
catMyMaybes ms = [x | Just x <- ms]

-- {do 블록}
-- do 블록에서도 왼쪽 화살표 바인딩의 좌변에 패턴 매칭을 사용할 수 있다.

putFirstChar = do
    (c:_) <- getLine
    putStrLn [c]

